const id = "hard-coded-scanning.md";
						const collection = "blog";
						const slug = "hard-coded-scanning";
						const body = "\n## The Backstage\n\nIf secrets are so sensitive, why do developers still hard code them in the codebase? It's not because they aren't concerned about security, they understand the risks of exposed secrets. But real world development is messy and often siloed, filled with challenges that make security an afterthought. We all have deep respect for our developers, they're incredibly smart and deeply knowledgeable about their code. Deadlines are tight, so many features are in the queue, debugging needs to be fast, and occasionally, developers just need to get things done. Security extra steps will be in the backlog with the seatbelt *\"Will remove later\"*.\n\n![sleep-meme](@assets/images/sleep-meme.png)\n\n## It's not a bug, it's human nature\n\nDevelopers are wired to solve problems efficiently. Hard coding a secret might feel like the simplest way to keep things moving. It happens for a few key reasons:\n\n#### <span class=\"accent\">A false sense of security</span>\n- *\"It's just an internal repo\"*\n- *\"Only our team has access\"*\n- *\"It's buried deep in code, no one will find it\"*\n\nThese assumptions feel reasonable until they're not. Internal repos can get exposed. Access controls can be broken. Your VCS environment can leak out. That AWS key you hard coded for convenience? It's one leaked commit away from becoming a security nightmare.\n\n#### <span class=\"accent\">Speed versus Security </span>\n\nHard coding secrets makes things work now. And in a fast moving development cycle, \"now\" often wins.\n- Rapid prototyping? Just drop in an API key.\n- Debugging an issue? Hard coded credentials to test faster.\n- Collaborating with teammates? Share keys in the code.\n\t\t\nIt's always meant to be temporary, until it isn't.\n\n#### <span class=\"accent\">The unintentional mistake</span>\n\nNot all hard coded secrets are intentional. Sometimes they sneak in:\n\n- Test credentials get left in the final commit.\n- Copied snippet from Stack Overflow or AI generated includes an embedded key.\n- A .gitignore rule is misconfigured, and a sensitive file gets pushed.\n\nNo one means to leak secrets. But when security relies on remembering an extra step, mistakes happen. A secret that was meant to be removed later gets forgotten. A piece of test code accidentally makes it into production. A private repository becomes public. And suddenly, what seemed like a harmless decision turns into a security incident. \n\n## The Real Cost of Leaked Secrets\n\nThe worst part? We don't see the cost of a secret leak until it's leaked. Maybe nothing happens, until a hacker stumbles upon it, a service revokes your key, or an entire system is compromised.\n\nHard coding secrets isn't just a bad habit. It's a risk that grows silently until it [explodes](https://www.ibm.com/reports/data-breach).\n\n### How Do We Catch This?\n\nWe don't just enforce security, we work _with_ developers, not against them. Security should integrate smoothly into the their daily SDLC which called AppSec processes without slowing teams down.\n\n#### A Real World Example\n\nLet's say we're working at a **blitzscaling startup**, where the product is developing at lightning speed to hit MVP and keep up with agile demands. The focus is on shipping fast , not security\n\n- **Cost is minimal** : there’s no budget for fancy security tools like commercial SAST tools\n- **GitLab is self-hosted** : no built-in  security scanning.\n- **Developer habits** : secrets, API keys, and credentials are often committed directly to the code because it's “internal.”\n\nWithout expensive tools, we try to bake open source tool called Gitleaks into our CI/CD pipeline. We chose this for its customizable regex rules and speed. Here's what we propose with goals rolling our scanning at scale.\n\nIn GitLab, each project has its own **`.gitlab-ci.yml`** file, defining its CI/CD pipeline. But managing security scans **project by project** doesn't scale well. We would need to manually add and update security rules in every repo, not happening.\n\nInstead, we **leverage pipeline includes**. This works like importing a library in code: we define a **centralized security pipeline** in a dedicated repo and then include it in every project's **`.gitlab-ci.yml`**.\n\n![gitleaks-diagram](@assets/images/gitleaks-diagram.png)\n\nHow it works:\n- Centralized Repo: We already have a dedicated repo maintained by **DevOps team**, defining general security policies. In this repo, we create a **security config template** that includes customized rules (keep reference copy in S3 bucket) \n- Each working repo includes the centralized **security pipeline**\n- **Scan results (artifacts)** are automatically **uploaded to S3** for investigation\n\nHere is the sample of gitleaks-ci.yml\n```yaml\nstages:\n  - secret-detection\n\n.gitleaks-rules: &gitleaks-rules\n  image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest\n  stage: secret-detection\n  tags:\n    - share-nonprod\n  script:\n    - aws s3 cp s3://share//gitlab-ci/security/gitleaks-rules.toml \"$CI_PROJECT_DIR\"/gitleaks-rules.toml\n  artifacts:\n    paths:\n      - gitleaks-rules.toml\n\n.gitleaks-scan: &gitleaks-scan\n  image:\n    name: path/dev-gitleaks:latest\n    entrypoint: [\"\"]\n  stage: secret-detection\n \n  tags:\n    - share-nonprod\n  needs: []\n  variables:\n    GIT_DEPTH: 0\n  before_script:\n    - git config --global --add safe.directory \"${CI_PROJECT_DIR}\"\n  script:\n    - gitleaks detect --config gitleaks-rules.toml ${TRACE+--log-level debug} --report-path gitleaks.output.json\n  artifacts:\n    name: \"$CI_JOB_NAME artifacts from $CI_PROJECT_NAME on $CI_COMMIT_REF_SLUG $CI_COMMIT_SHORT_SHA\"\n    when: always\n    paths:\n      - gitleaks.*\n\n.gitleaks-output-upload-to-s3: &gitleaks-output-upload-to-s3\n  stage: secret-detection\n  tags:\n    - share-nonprod\n  needs:\n    - gitleaks-scan\n  image: registry.gitlab.com/gitlab-org/cloud-deploy/aws-base:latest\n  script:\n    - aws s3 cp gitleaks.* s3://secret-scan/$CI_PROJECT_NAME/$CI_COMMIT_BRANCH/\n    - echo \"uploaded successful\"\n```\n## Final thoughts\nAter detecting the secrets, simply deleting a secret from the latest commit **does not mean it's gone**, it's already in history, caches, forks, and clones. Attackers and automated tools can still find and exploit it.\n\nSome next moves: \n- Use centralized secret manager like **AWS Secrets Manager, HashiCorp Vault, or Doppler** \n- Enforce pre-commit with gitleaks to catch secrets before dev commits\n- Security Awareness, work with them, and educate your teams\n- Rotate and monitor secret \n\n";
						const data = {author:"Hazy",pubDatetime:new Date(1741824000000),title:"Secure Your Codebase Secrets Scanning",featured:false,draft:false,tags:["secrets scanning","application security","appsec","security"],description:"Think about managing the risks of hard coded secrets."};
						const _internal = {
							type: 'content',
							filePath: "/Users/4azy/lune/code/flouciel.github.io/src/content/blog/hard-coded-scanning.md",
							rawData: undefined,
						};

export { _internal, body, collection, data, id, slug };
